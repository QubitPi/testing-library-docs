"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[8231],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=l(n),d=o,f=m["".concat(u,".").concat(d)]||m[d]||c[d]||a;return n?r.createElement(f,s(s({ref:t},p),{},{components:n})):r.createElement(f,s({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9022:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),s=["components"],i={id:"faq",title:"FAQ"},u=void 0,l={unversionedId:"vue-testing-library/faq",id:"vue-testing-library/faq",title:"FAQ",description:"See also the main FAQ for questions not specific",source:"@site/docs/vue-testing-library/faq.mdx",sourceDirName:"vue-testing-library",slug:"/vue-testing-library/faq",permalink:"/docs/vue-testing-library/faq",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/vue-testing-library/faq.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750827853,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"faq",title:"FAQ"},sidebar:"docs",previous:{title:"API",permalink:"/docs/vue-testing-library/api"},next:{title:"Cheatsheet",permalink:"/docs/vue-testing-library/cheatsheet"}},p={},c=[],m={toc:c};function d(e){var t=e.components,n=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"See also the ",(0,a.kt)("a",{parentName:"p",href:"/docs/dom-testing-library/faq"},"main FAQ")," for questions not specific\nto Vue testing."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Is Vue Testing Library a replacement for the official @vue/test-utils?"),(0,a.kt)("p",null,"Short answer: yes, it is. If you use Vue Testing Library (VTL) there's no need\nto install ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/vuejs/vue-test-utils"},"@vue/test-utils"),"."),(0,a.kt)("p",null,"Longer answer: VTL is built on top of @vue/test-utils. The official library is\nused to render Vue components (by calling ",(0,a.kt)("a",{parentName:"p",href:"https://vue-test-utils.vuejs.org/api/#mount"},(0,a.kt)("inlineCode",{parentName:"a"},"mount")),") and exposes some of\nits methods (while hiding others). You can check the full list of available\nmethods in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/vue-testing-library/api"},"API")," section.")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Do I need to install DOM Testing Library?"),(0,a.kt)("p",null,"Nope! VTL imports everything it needs from DOM Testing Library, and then\nre-exports it.")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"What queries does Vue Testing Library provide?"),(0,a.kt)("p",null,"All queries from DOM Testing Library. See ",(0,a.kt)("a",{parentName:"p",href:"/docs/queries/about"},"Queries")," for full\nlist.")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"If I can't use shallow rendering, how do I mock out components in tests?"),(0,a.kt)("p",null,"In general, you should avoid mocking out components (see\n",(0,a.kt)("a",{parentName:"p",href:"/docs/guiding-principles"},"the Guiding Principles section"),")."),(0,a.kt)("p",null,"However if you need to, you can either use Jest's\n",(0,a.kt)("a",{parentName:"p",href:"https://facebook.github.io/jest/docs/en/manual-mocks.html"},"mocking feature")," or\nthe ",(0,a.kt)("a",{parentName:"p",href:"https://vue-test-utils.vuejs.org/api/options.html#stubs"},(0,a.kt)("inlineCode",{parentName:"a"},"stubs"))," key provided by @vue/test-utils."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {render} from '@testing-library/vue'\nimport Component from './Component'\n\ntest('Can stub components', () => {\n  render(Component, {\n    global: {stubs: ['FontAwesomeIcon']},\n  })\n})\n")),(0,a.kt)("p",null,"You can check out a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/testing-library/vue-testing-library/blob/master/src/__tests__/stubs.js"},"working example")," in the GitHub repository of\nVTL.")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"How can I test if an element has appeared / has disappeared?"),(0,a.kt)("p",null,"Check the ",(0,a.kt)("a",{parentName:"p",href:"/docs/guide-disappearance"},"Appearance and Disappearance")," section of the\nGuide for available methods to test appearance and disappearance."),(0,a.kt)("p",null,"If you want to check if an element was never rendered, you might want to write\nsomething like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"expect(queryByText('submit')).toBeNull()\n\n// or, if using jest-dom:\nimport '@testing-library/jest-dom'\nexpect(queryByText('submit')).not.toBeInTheDocument()\n"))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Why does my Vue Router state seem to be shared between tests?"),(0,a.kt)("p",null,"By default, Vue Router uses\n",(0,a.kt)("a",{parentName:"p",href:"https://router.vuejs.org/api/#mode"},(0,a.kt)("inlineCode",{parentName:"a"},"hash")," routing mode"),", which stores route\nupdates in ",(0,a.kt)("inlineCode",{parentName:"p"},"window.location"),". Test runners, such as Jest, do not reset the JSDOM\nenvironment in between test invocations, so route transitions from previous\ntests can leak into subsequent tests, even though a new Vue Router is created\nwith each call to ",(0,a.kt)("inlineCode",{parentName:"p"},"render"),"."),(0,a.kt)("p",null,"To work around this issue, pass an instantiated router using ",(0,a.kt)("inlineCode",{parentName:"p"},"abstract")," mode.\n",(0,a.kt)("inlineCode",{parentName:"p"},"abstract")," mode does not store route information on the JSDOM ",(0,a.kt)("inlineCode",{parentName:"p"},"window"),", so\nrouting information will not leak between tests. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {render} from '@testing-library/vue'\nimport Component from './Component.vue'\nimport VueRouter from 'vue-router'\n\ntest('uses abstract mode for the router', async () => {\n  const router = new VueRouter({\n    mode: 'abstract',\n    routes: [\n      // Your routes here\n    ],\n  })\n\n  const renderResult = render(Component, {\n    routes: router,\n  })\n\n  // Unlike the router in `hash` mode, the initial routing stack is empty. So,\n  // you need to push an initial route to the stack.\n  await router.push('/')\n})\n")),(0,a.kt)("p",null,"To reduce boilerplate, you can create a custom render function to use throughout\nyour test suite. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// test-utils.js\n\nimport {render} from '@testing-library/vue'\nimport VueRouter from 'vue-router'\n\nexport async function renderApp(component, options) {\n  const router = new VueRouter({\n    mode: 'abstract',\n    routes: [\n      // Your routes here\n    ],\n  })\n\n  const renderResult = render(component, {\n    routes: router,\n    ...options,\n  })\n\n  // Unlike the router in `hash` mode, the initial routing stack is empty. So,\n  // you need to push an initial route to the stack.\n  await router.push('/')\n\n  return renderResult\n}\n"))))}d.isMDXComponent=!0}}]);