"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[610],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),d=s,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?r.createElement(g,a(a({ref:t},c),{},{components:n})):r.createElement(g,a({ref:t},c))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,a=new Array(i);a[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,a[1]=o;for(var p=2;p<i;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3058:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>u});var r=n(7462),s=n(3366),i=(n(7294),n(3905)),a=["components"],o={id:"example",title:"Example",sidebar_label:"Example"},l=void 0,p={unversionedId:"svelte-testing-library/example",id:"svelte-testing-library/example",title:"Example",description:"For additional resources, patterns, and best practices about testing Svelte",source:"@site/docs/svelte-testing-library/example.mdx",sourceDirName:"svelte-testing-library",slug:"/svelte-testing-library/example",permalink:"/docs/svelte-testing-library/example",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/svelte-testing-library/example.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750828179,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"example",title:"Example",sidebar_label:"Example"},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/svelte-testing-library/intro"},next:{title:"Setup",permalink:"/docs/svelte-testing-library/setup"}},c={},u=[{value:"Basic",id:"basic",level:2},{value:"Events",id:"events",level:2},{value:"Slots",id:"slots",level:2},{value:"Two-way data binding",id:"two-way-data-binding",level:2},{value:"Contexts",id:"contexts",level:2}],m={toc:u};function d(e){var t=e.components,n=(0,s.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For additional resources, patterns, and best practices about testing Svelte\ncomponents and other Svelte features, take a look at the ",(0,i.kt)("a",{parentName:"p",href:"https://sveltesociety.dev/recipes/testing-and-debugging/unit-testing-svelte-component"},"Svelte Society testing\nrecipes"),"."),(0,i.kt)("h2",{id:"basic"},"Basic"),(0,i.kt)("p",null,"This basic example demonstrates how to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pass props to your Svelte component using ",(0,i.kt)("inlineCode",{parentName:"li"},"render")),(0,i.kt)("li",{parentName:"ul"},"Query the structure of your component's DOM elements using ",(0,i.kt)("inlineCode",{parentName:"li"},"screen")),(0,i.kt)("li",{parentName:"ul"},"Interact with your component using ",(0,i.kt)("a",{parentName:"li",href:"/docs/user-event/intro"},(0,i.kt)("inlineCode",{parentName:"a"},"@testing-library/user-event"))),(0,i.kt)("li",{parentName:"ul"},"Make assertions using ",(0,i.kt)("inlineCode",{parentName:"li"},"expect"),", using matchers from\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/testing-library/jest-dom"},(0,i.kt)("inlineCode",{parentName:"a"},"@testing-library/jest-dom")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="greeter.svelte"',title:'"greeter.svelte"'},'<script>\n  export let name\n\n  let showGreeting = false\n\n  const handleClick = () => (showGreeting = true)\n<\/script>\n\n<button on:click="{handleClick}">Greet</button>\n\n{#if showGreeting}\n<p>Hello {name}</p>\n{/if}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="greeter.test.js"',title:'"greeter.test.js"'},"import {render, screen} from '@testing-library/svelte'\nimport userEvent from '@testing-library/user-event'\nimport {expect, test} from 'vitest'\n\nimport Greeter from './greeter.svelte'\n\ntest('no initial greeting', () => {\n  render(Greeter, {name: 'World'})\n\n  const button = screen.getByRole('button', {name: 'Greet'})\n  const greeting = screen.queryByText(/hello/iu)\n\n  expect(button).toBeInTheDocument()\n  expect(greeting).not.toBeInTheDocument()\n})\n\ntest('greeting appears on click', async () => {\n  const user = userEvent.setup()\n  render(Greeter, {name: 'World'})\n\n  const button = screen.getByRole('button')\n  await user.click(button)\n  const greeting = screen.getByText(/hello world/iu)\n\n  expect(greeting).toBeInTheDocument()\n})\n")),(0,i.kt)("h2",{id:"events"},"Events"),(0,i.kt)("p",null,"Events can be tested using spy functions. If you're using Vitest you can use\n",(0,i.kt)("a",{parentName:"p",href:"https://vitest.dev/api/vi.html#vi-fn"},(0,i.kt)("inlineCode",{parentName:"a"},"vi.fn()"))," to create a spy."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Consider using function props to make testing events easier.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="button-with-event.svelte"',title:'"button-with-event.svelte"'},"<button on:click>click me</button>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="button-with-prop.svelte"',title:'"button-with-prop.svelte"'},'<script>\n  export let onClick\n<\/script>\n\n<button on:click="{onClick}">click me</button>\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="button.test.ts"',title:'"button.test.ts"'},"import {render, screen} from '@testing-library/svelte'\nimport userEvent from '@testing-library/user-event'\nimport {expect, test, vi} from 'vitest'\n\nimport ButtonWithEvent from './button-with-event.svelte'\nimport ButtonWithProp from './button-with-prop.svelte'\n\ntest('button with event', async () => {\n  const user = userEvent.setup()\n  const onClick = vi.fn()\n\n  const {component} = render(ButtonWithEvent)\n  component.$on('click', onClick)\n\n  const button = screen.getByRole('button')\n  await user.click(button)\n\n  expect(onClick).toHaveBeenCalledOnce()\n})\n\ntest('button with function prop', async () => {\n  const user = userEvent.setup()\n  const onClick = vi.fn()\n\n  render(ButtonWithProp, {onClick})\n\n  const button = screen.getByRole('button')\n  await user.click(button)\n\n  expect(onClick).toHaveBeenCalledOnce()\n})\n")),(0,i.kt)("h2",{id:"slots"},"Slots"),(0,i.kt)("p",null,"Slots cannot be tested directly. It's usually easier to structure your code so\nthat you can test the user-facing results, leaving any slots as an\nimplementation detail."),(0,i.kt)("p",null,'However, if slots are an important developer-facing API of your component, you\ncan use a wrapper component and "dummy" children to test them. Test IDs can be\nhelpful when testing slots in this manner.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="heading.svelte"',title:'"heading.svelte"'},"<h1>\n  <slot />\n</h1>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="heading.test.svelte"',title:'"heading.test.svelte"'},"<script>\n  import Heading from './heading.svelte'\n<\/script>\n\n<Heading>\n  <span data-testid=\"child\" />\n</Heading>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="heading.test.js"',title:'"heading.test.js"'},"import {render, screen, within} from '@testing-library/svelte'\nimport {expect, test} from 'vitest'\n\nimport HeadingTest from './heading.test.svelte'\n\ntest('heading with slot', () => {\n  render(HeadingTest)\n\n  const heading = screen.getByRole('heading')\n  const child = within(heading).getByTestId('child')\n\n  expect(child).toBeInTheDocument()\n})\n")),(0,i.kt)("h2",{id:"two-way-data-binding"},"Two-way data binding"),(0,i.kt)("p",null,"Two-way data binding cannot be tested directly. It's usually easier to structure\nyour code so that you can test the user-facing results, leaving the binding as\nan implementation detail."),(0,i.kt)("p",null,"However, if two-way binding is an important developer-facing API of your\ncomponent, you can use a wrapper component and writable store to test the\nbinding itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="text-input.svelte"',title:'"text-input.svelte"'},'<script>\n  export let value = \'\'\n<\/script>\n\n<input type="text" bind:value="{value}" />\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="text-input.test.svelte"',title:'"text-input.test.svelte"'},"<script>\n  import TextInput from './text-input.svelte'\n\n  export let valueStore\n<\/script>\n\n<TextInput bind:value=\"{$valueStore}\" />\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="text-input.test.js"',title:'"text-input.test.js"'},"import {render, screen} from '@testing-library/svelte'\nimport userEvent from '@testing-library/user-event'\nimport {get, writable} from 'svelte/store'\nimport {expect, test} from 'vitest'\n\nimport TextInputTest from './text-input.test.svelte'\n\ntest('text input with value binding', async () => {\n  const user = userEvent.setup()\n  const valueStore = writable('')\n\n  render(TextInputTest, {valueStore})\n\n  const input = screen.getByRole('textbox')\n  await user.type(input, 'hello world')\n\n  expect(get(valueStore)).toBe('hello world')\n})\n")),(0,i.kt)("h2",{id:"contexts"},"Contexts"),(0,i.kt)("p",null,"If your component requires access to contexts, you can pass those contexts in\nwhen you ",(0,i.kt)("a",{parentName:"p",href:"/docs/svelte-testing-library/api#component-options"},(0,i.kt)("inlineCode",{parentName:"a"},"render"))," the component. When you use options like\n",(0,i.kt)("inlineCode",{parentName:"p"},"context"),", be sure to place props under the ",(0,i.kt)("inlineCode",{parentName:"p"},"props")," key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="notifications-provider.svelte"',title:'"notifications-provider.svelte"'},"<script>\n  import {setContext} from 'svelte'\n  import {writable} from 'svelte/stores'\n\n  setContext('messages', writable([]))\n<\/script>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="notifications.svelte"',title:'"notifications.svelte"'},"<script>\n  import {getContext} from 'svelte'\n\n  export let label\n\n  const messages = getContext('messages')\n<\/script>\n\n<div role=\"status\" aria-label=\"{label}\">\n  {#each $messages as message (message.id)}\n  <p>{message.text}</p>\n  <hr />\n  {/each}\n</div>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="notifications.test.js"',title:'"notifications.test.js"'},"import {render, screen} from '@testing-library/svelte'\nimport {readable} from 'svelte/store'\nimport {expect, test} from 'vitest'\n\nimport Notifications from './notifications.svelte'\n\ntest('notifications with messages from context', async () => {\n  const messages = readable([\n    {id: 'abc', text: 'hello'},\n    {id: 'def', text: 'world'},\n  ])\n\n  render(Notifications, {\n    context: new Map([['messages', messages]]),\n    props: {label: 'Notifications'},\n  })\n\n  const status = screen.getByRole('status', {name: 'Notifications'})\n\n  expect(status).toHaveTextContent('hello world')\n})\n")))}d.isMDXComponent=!0}}]);