"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[2984],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2714:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>u});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={id:"faq",title:"FAQ"},l=void 0,c={unversionedId:"react-testing-library/faq",id:"react-testing-library/faq",title:"FAQ",description:"See also the main FAQ for questions not specific",source:"@site/docs/react-testing-library/faq.mdx",sourceDirName:"react-testing-library",slug:"/react-testing-library/faq",permalink:"/docs/react-testing-library/faq",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/react-testing-library/faq.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750827853,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"faq",title:"FAQ"},sidebar:"docs",previous:{title:"Migrate from Enzyme",permalink:"/docs/react-testing-library/migrate-from-enzyme"},next:{title:"Cheatsheet",permalink:"/docs/react-testing-library/cheatsheet"}},p={},u=[],d={toc:u};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"See also the ",(0,o.kt)("a",{parentName:"p",href:"/docs/dom-testing-library/faq"},"main FAQ")," for questions not specific\nto React testing."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"How do I test input onChange handlers?"),(0,o.kt)("p",null,"TL;DR:\n",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/github/kentcdodds/react-testing-library-examples/tree/main/?module=%2Fsrc%2F__tests__%2Fon-change.js&previewwindow=tests"},"Go to the ",(0,o.kt)("inlineCode",{parentName:"a"},"on-change.js")," example")),(0,o.kt)("p",null,"In summary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'\nimport {render, fireEvent} from '@testing-library/react'\n\ntest('change values via the fireEvent.change method', () => {\n  const handleChange = jest.fn()\n  const {container} = render(<input type=\"text\" onChange={handleChange} />)\n  const input = container.firstChild\n  fireEvent.change(input, {target: {value: 'a'}})\n  expect(handleChange).toHaveBeenCalledTimes(1)\n  expect(input.value).toBe('a')\n})\n\ntest('select drop-downs must use the fireEvent.change', () => {\n  const handleChange = jest.fn()\n  const {container} = render(\n    <select onChange={handleChange}>\n      <option value=\"1\">1</option>\n      <option value=\"2\">2</option>\n    </select>,\n  )\n  const select = container.firstChild\n  const option1 = container.getElementsByTagName('option').item(0)\n  const option2 = container.getElementsByTagName('option').item(1)\n\n  fireEvent.change(select, {target: {value: '2'}})\n\n  expect(handleChange).toHaveBeenCalledTimes(1)\n  expect(option1.selected).toBe(false)\n  expect(option2.selected).toBe(true)\n})\n\ntest('checkboxes (and radios) must use fireEvent.click', () => {\n  const handleChange = jest.fn()\n  const {container} = render(<input type=\"checkbox\" onChange={handleChange} />)\n  const checkbox = container.firstChild\n  fireEvent.click(checkbox)\n  expect(handleChange).toHaveBeenCalledTimes(1)\n  expect(checkbox.checked).toBe(true)\n})\n")),(0,o.kt)("p",null,"If you've used enzyme or React's TestUtils, you may be accustomed to changing\ninputs like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"input.value = 'a'\nSimulate.change(input)\n")),(0,o.kt)("p",null,"We can't do this with React Testing Library because React actually keeps track\nof any time you assign the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," property on an ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," and so when you fire\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"change")," event, React thinks that the value hasn't actually been changed."),(0,o.kt)("p",null,"This works for Simulate because they use internal APIs to fire special simulated\nevents. With React Testing Library, we try to avoid implementation details to\nmake your tests more resilient."),(0,o.kt)("p",null,"So we have it worked out for the change event handler to set the property for\nyou in a way that's not trackable by React. This is why you must pass the value\nas part of the ",(0,o.kt)("inlineCode",{parentName:"p"},"change")," method call.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"How do I test error boundaries"),(0,o.kt)("p",null,"To test if an error boundary successfully catches an error, you should make sure that if the fallback of the boundary is displayed when a child threw."),(0,o.kt)("p",null,"Here's an example of how you can test an error boundary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'\nimport {render, screen} from '@testing-library/react'\n\nclass ErrorBoundary extends React.Component {\n  state = {error: null}\n  static getDerivedStateFromError(error) {\n    return {error}\n  }\n  render() {\n    const {error} = this.state\n    if (error) {\n      return <div>Something went wrong</div>\n    }\n    return this.props.children\n  }\n}\n\ntest('error boundary catches error', () => {\n  const {container} = render(\n    <ErrorBoundary>\n      <BrokenComponent />\n    </ErrorBoundary>,\n  )\n  expect(container.textContent).toEqual('Something went wrong.')\n})\n")),(0,o.kt)("p",null,"If the error boundary did not catch the error, the test would fail since the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," call would throw the error the Component produced."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"React 18 will call ",(0,o.kt)("inlineCode",{parentName:"p"},"console.error")," with an extended error message.\nReact 19 will call ",(0,o.kt)("inlineCode",{parentName:"p"},"console.warn")," with an extended error message."),(0,o.kt)("p",{parentName:"admonition"},"To disable the additional ",(0,o.kt)("inlineCode",{parentName:"p"},"console.warn")," call in React 19, you can provide a custom ",(0,o.kt)("inlineCode",{parentName:"p"},"onCaughtError")," callback e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"render(<App />, {onCaughtError: () => {}})"),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"onCaughtError")," is not supported in React 18."))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Can I write unit tests with this library?"),(0,o.kt)("p",null,"Definitely yes! You can write unit and integration tests with this library. See\nbelow for more on how to mock dependencies (because this library intentionally\ndoes NOT support shallow rendering) if you want to unit test a high level\ncomponent. The tests in this project show several examples of unit testing with\nthis library."),(0,o.kt)("p",null,"As you write your tests, keep in mind:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The more your tests resemble the way your software is used, the more\nconfidence they can give you. - ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/kentcdodds/status/977018512689455106"},"17 Feb 2018")))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"How do I test thrown errors in a Component or Hook?"),(0,o.kt)("p",null,"If a component throws during render, the origin of the state update will throw if wrapped in ",(0,o.kt)("inlineCode",{parentName:"p"},"act"),".\nBy default, ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"fireEvent")," are wrapped in ",(0,o.kt)("inlineCode",{parentName:"p"},"act"),".\nYou can just wrap it in a try-catch or use dedicated matchers if your test runner supports these.\nFor example, in Jest you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"toThrow"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function Thrower() {\n  throw new Error('I throw')\n}\n\ntest('it throws', () => {\n  expect(() => render(<Thrower />)).toThrow('I throw')\n})\n")),(0,o.kt)("p",null,"The same applies to Hooks and ",(0,o.kt)("inlineCode",{parentName:"p"},"renderHook"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function useThrower() {\n  throw new Error('I throw')\n}\n\ntest('it throws', () => {\n  expect(() => renderHook(useThrower)).toThrow('I throw')\n})\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"React 18 will call ",(0,o.kt)("inlineCode",{parentName:"p"},"console.error")," with an extended error message.\nReact 19 will call ",(0,o.kt)("inlineCode",{parentName:"p"},"console.warn")," with an extended error message unless the state update is wrapped in ",(0,o.kt)("inlineCode",{parentName:"p"},"act"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"render"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"renderHook")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"fireEvent")," are wrapped in ",(0,o.kt)("inlineCode",{parentName:"p"},"act")," by default."))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"If I can't use shallow rendering, how do I mock out components in tests?"),(0,o.kt)("p",null,"In general, you should avoid mocking out components (see\n",(0,o.kt)("a",{parentName:"p",href:"/docs/guiding-principles"},"the Guiding Principles section"),"). However, if you need\nto, then try to use\n",(0,o.kt)("a",{parentName:"p",href:"https://facebook.github.io/jest/docs/en/manual-mocks.html"},"Jest's mocking feature"),".\nOne case where I've found mocking to be especially useful is for animation\nlibraries. I don't want my tests to wait for animations to end."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"jest.mock('react-transition-group', () => {\n  const FakeTransition = jest.fn(({children}) => children)\n  const FakeCSSTransition = jest.fn(props =>\n    props.in ? <FakeTransition>{props.children}</FakeTransition> : null,\n  )\n  return {CSSTransition: FakeCSSTransition, Transition: FakeTransition}\n})\n\ntest('you can mock things with jest.mock', () => {\n  const {getByTestId, queryByTestId} = render(\n    <HiddenMessage initialShow={true} />,\n  )\n  expect(queryByTestId('hidden-message')).toBeTruthy() // we just care it exists\n  // hide the message\n  fireEvent.click(getByTestId('toggle-message'))\n  // in the real world, the CSSTransition component would take some time\n  // before finishing the animation which would actually hide the message.\n  // So we've mocked it out for our tests to make it happen instantly\n  expect(queryByTestId('hidden-message')).toBeNull() // we just care it doesn't exist\n})\n")),(0,o.kt)("p",null,"Note that because they're Jest mock functions (",(0,o.kt)("inlineCode",{parentName:"p"},"jest.fn()"),"), you could also make\nassertions on those as well if you wanted."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/example-react-transition-group"},"Open full test")," for the full example."),(0,o.kt)("p",null,"This looks like more work than shallow rendering (and it is), but it gives you\nmore confidence so long as your mock resembles the thing you're mocking closely\nenough."),(0,o.kt)("p",null,"If you want to make things more like shallow rendering, then you could do\nsomething more ",(0,o.kt)("a",{parentName:"p",href:"/docs/example-react-transition-group"},"like this"),"."),(0,o.kt)("p",null,"Learn more about how Jest mocks work from my blog post:\n",(0,o.kt)("a",{parentName:"p",href:"https://kentcdodds.com/blog/but-really-what-is-a-javascript-mock"},'"But really, what is a JavaScript mock?"'))),(0,o.kt)("details",null,(0,o.kt)("summary",null,'What about enzyme is "bloated with complexity and features" and "encourage poor testing practices"?'),(0,o.kt)("p",null,"Most of the damaging features have to do with encouraging testing implementation\ndetails. Primarily, these are\n",(0,o.kt)("a",{parentName:"p",href:"http://airbnb.io/enzyme/docs/api/shallow.html"},"shallow rendering"),", APIs which\nallow selecting rendered elements by component constructors, and APIs which\nallow you to get and interact with component instances (and their\nstate/properties) (most of enzyme's wrapper APIs allow this)."),(0,o.kt)("p",null,"The guiding principle for this library is:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The more your tests resemble the way your software is used, the more\nconfidence they can give you. - ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/kentcdodds/status/977018512689455106"},"17 Feb 2018"))),(0,o.kt)("p",null,"Because users can't directly interact with your app's component instances,\nassert on their internal state or what components they render, or call their\ninternal methods, doing those things in your tests reduce the confidence they're\nable to give you."),(0,o.kt)("p",null,"That's not to say that there's never a use case for doing those things, so they\nshould be possible to accomplish, just not the default and natural way to test\nreact components.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Why isn't snapshot diffing working?"),(0,o.kt)("p",null,"If you use the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jest-community/snapshot-diff"},"snapshot-diff"),"\nlibrary to save snapshot diffs, it won't work out of the box because this\nlibrary uses the DOM which is mutable. Changes don't return new objects so\nsnapshot-diff will think it's the same object and avoid diffing it."),(0,o.kt)("p",null,"Luckily there's an easy way to make it work: clone the DOM when passing it into\nsnapshot-diff. It looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const firstVersion = container.cloneNode(true)\n// Do some changes\nsnapshotDiff(firstVersion, container.cloneNode(true))\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,'How do I fix "an update was not wrapped in act(...)" warnings?'),(0,o.kt)("p",null,"This warning is usually caused by an async operation causing an update after the\ntest has already finished. There are 2 approaches to resolve it:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Wait for the result of the operation in your test by using one of\n",(0,o.kt)("a",{parentName:"li",href:"/docs/dom-testing-library/api-async"},"the async utilities")," like\n",(0,o.kt)("a",{parentName:"li",href:"/docs/dom-testing-library/api-async#waitfor"},"waitFor")," or a\n",(0,o.kt)("a",{parentName:"li",href:"/docs/queries/about#types-of-queries"},(0,o.kt)("inlineCode",{parentName:"a"},"find*")," query"),". For example:\n",(0,o.kt)("inlineCode",{parentName:"li"},"const userAddress = await findByLabel(/address/i)"),"."),(0,o.kt)("li",{parentName:"ol"},"Mocking out the asynchronous operation so that it doesn't trigger state\nupdates.")),(0,o.kt)("p",null,"Generally speaking, approach 1 is preferred since it better matches the\nexpectations of a user interacting with your app."),(0,o.kt)("p",null,"In addition, you may find\n",(0,o.kt)("a",{parentName:"p",href:"https://kentcdodds.com/blog/write-fewer-longer-tests"},"this blog post")," helpful\nas you consider how best to write tests that give you confidence and avoid these\nwarnings.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"What level of a component tree should I test? Children, parents, or both?"),(0,o.kt)("p",null,"Following the guiding principle of this library, it is useful to break down how\ntests are organized around how the user experiences and interacts with\napplication functionality rather than around specific components themselves. In\nsome cases, for example for reusable component libraries, it might be useful to\ninclude developers in the list of users to test for and test each of the\nreusable components individually. Other times, the specific break down of a\ncomponent tree is just an implementation detail and testing every component\nwithin that tree individually can cause issues (see\n",(0,o.kt)("a",{parentName:"p",href:"https://kentcdodds.com/blog/avoid-the-test-user"},"https://kentcdodds.com/blog/avoid-the-test-user"),")."),(0,o.kt)("p",null,"In practice this means that it is often preferable to test high enough up the\ncomponent tree to simulate realistic user interactions. The question of whether\nit is worth additionally testing at a higher or lower level on top of this comes\ndown to a question of tradeoffs and what will provide enough value for the cost\n(see ",(0,o.kt)("a",{parentName:"p",href:"https://kentcdodds.com/blog/unit-vs-integration-vs-e2e-tests"},"https://kentcdodds.com/blog/unit-vs-integration-vs-e2e-tests")," on more info\non different levels of testing)."),(0,o.kt)("p",null,"For a more in-depth discussion of this topic see\n",(0,o.kt)("a",{parentName:"p",href:"https://youtu.be/0qmPdcV-rN8"},"this video"),".")))}h.isMDXComponent=!0}}]);