"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[6539],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(n),u=a,h=m["".concat(p,".").concat(u)]||m[u]||c[u]||i;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9794:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],l={id:"api",title:"API"},p=void 0,s={unversionedId:"marko-testing-library/api",id:"marko-testing-library/api",title:"API",description:"Marko Testing Library re-exports everything from DOM Testing Library as well",source:"@site/docs/marko-testing-library/api.mdx",sourceDirName:"marko-testing-library",slug:"/marko-testing-library/api",permalink:"/docs/marko-testing-library/api",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/marko-testing-library/api.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750827853,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"api",title:"API"},sidebar:"docs",previous:{title:"Setup",permalink:"/docs/marko-testing-library/setup"},next:{title:"Introduction",permalink:"/docs/preact-testing-library/intro"}},d={},c=[{value:"<code>render</code>",id:"render",level:2},{value:"<code>render</code> Options",id:"render-options",level:3},{value:"<code>container</code>",id:"container",level:4},{value:"<code>render</code> Result",id:"render-result",level:2},{value:"<code>...queries</code>",id:"queries",level:3},{value:"<code>debug</code>",id:"debug",level:3},{value:"<code>rerender</code>",id:"rerender",level:3},{value:"<code>emitted</code>",id:"emitted",level:3},{value:"<code>cleanup</code>",id:"cleanup",level:3},{value:"<code>container</code>",id:"container-1",level:3},{value:"<code>fireEvent</code>",id:"fireevent",level:2},{value:"<code>cleanup</code>",id:"cleanup-1",level:2}],m={toc:c};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Marko Testing Library")," re-exports everything from ",(0,i.kt)("inlineCode",{parentName:"p"},"DOM Testing Library")," as well\nas these methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#render"},(0,i.kt)("inlineCode",{parentName:"a"},"render")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#render-options"},(0,i.kt)("inlineCode",{parentName:"a"},"render")," Options"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#container"},(0,i.kt)("inlineCode",{parentName:"a"},"container"))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#render-result"},(0,i.kt)("inlineCode",{parentName:"a"},"render")," Result"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#queries"},(0,i.kt)("inlineCode",{parentName:"a"},"...queries"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#debug"},(0,i.kt)("inlineCode",{parentName:"a"},"debug"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#rerender"},(0,i.kt)("inlineCode",{parentName:"a"},"rerender"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#emitted"},(0,i.kt)("inlineCode",{parentName:"a"},"emitted"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#cleanup"},(0,i.kt)("inlineCode",{parentName:"a"},"cleanup"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#container-1"},(0,i.kt)("inlineCode",{parentName:"a"},"container"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#cleanup-1"},(0,i.kt)("inlineCode",{parentName:"a"},"cleanup")))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"render"},(0,i.kt)("inlineCode",{parentName:"h2"},"render")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function render(\n  template, // A Marko template to render\n  input, // Input for the above template\n  options // You won't often use this, expand below for docs on options\n)\n")),(0,i.kt)("p",null,"Render into a container which is appended to ",(0,i.kt)("inlineCode",{parentName:"p"},"document.body"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import {render} from '@marko/testing-library'\nimport MyTemplate from './my-template.marko'\n\nrender(MyTemplate)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import {render, screen} from '@marko/testing-library'\nimport Greeting from './greeting.marko'\n\ntest('renders a message', async () => {\n  const {container} = await render(Greeting, {name: 'Marko'})\n  expect(screen.getByText(/Marko/)).toBeInTheDocument()\n  expect(container.firstChild).toMatchInlineSnapshot(`\n    <h1>Hello, Marko!</h1>\n  `)\n})\n")),(0,i.kt)("h3",{id:"render-options"},(0,i.kt)("inlineCode",{parentName:"h3"},"render")," Options"),(0,i.kt)("p",null,"You won't often need to specify options, but if you ever do, here are the\navailable options which you can provide as the third argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"render"),"."),(0,i.kt)("h4",{id:"container"},(0,i.kt)("inlineCode",{parentName:"h4"},"container")),(0,i.kt)("p",null,"By default for client-side tests, ",(0,i.kt)("inlineCode",{parentName:"p"},"Marko Testing Library")," will create a ",(0,i.kt)("inlineCode",{parentName:"p"},"div"),"\nand append that ",(0,i.kt)("inlineCode",{parentName:"p"},"div")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"document.body")," and this is where your component\nwill be rendered. If you provide your own HTMLElement ",(0,i.kt)("inlineCode",{parentName:"p"},"container")," via this\noption, it will not be appended to the ",(0,i.kt)("inlineCode",{parentName:"p"},"document.body")," automatically."),(0,i.kt)("p",null,"For example: If you are unit testing a ",(0,i.kt)("inlineCode",{parentName:"p"},"tablebody")," element, it cannot be a child\nof a ",(0,i.kt)("inlineCode",{parentName:"p"},"div"),". In this case, you can specify a ",(0,i.kt)("inlineCode",{parentName:"p"},"table")," as the render ",(0,i.kt)("inlineCode",{parentName:"p"},"container"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const table = document.createElement('table')\n\nconst {container} = await render(MyTableBody, null, {\n  container: document.body.appendChild(table),\n})\n")),(0,i.kt)("h2",{id:"render-result"},(0,i.kt)("inlineCode",{parentName:"h2"},"render")," Result"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," method returns a promise which resolves with an object that has a\nfew properties:"),(0,i.kt)("h3",{id:"queries"},(0,i.kt)("inlineCode",{parentName:"h3"},"...queries")),(0,i.kt)("p",null,"The most important feature of ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," is that the queries from\n",(0,i.kt)("a",{parentName:"p",href:"/docs/queries/about"},"the Core API")," are automatically returned with their first\nargument bound to the results of rendering your component."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/docs/queries/about#types-of-queries"},"Queries")," for a complete list."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const {getByLabelText, queryAllByTestId} = await render(MyTemplate)\n")),(0,i.kt)("p",null,"Alternatively, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/queries/about#screen"},"top-level ",(0,i.kt)("inlineCode",{parentName:"a"},"screen")," method")," to query into all\ncurrently rendered components in the ",(0,i.kt)("inlineCode",{parentName:"p"},"document.body"),", eg:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'import { render, screen } from "@marko/testing-library"\n\nawait render(MyTemplate)\nconst el = screen.getByText(...)\n')),(0,i.kt)("h3",{id:"debug"},(0,i.kt)("inlineCode",{parentName:"h3"},"debug")),(0,i.kt)("p",null,"This method is a shortcut for logging the ",(0,i.kt)("inlineCode",{parentName:"p"},"prettyDOM")," for all children inside of\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"container"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import {render} from '@marko/testing-library'\nimport Greeting from './greeting.marko'\n\nconst {debug} = await render(Greeting, {name: 'World'})\ndebug()\n\n// <h1>Hello World</h1>\n// you can also pass an element: debug(getByTestId('messages'))\n")),(0,i.kt)("p",null,"This is a simple wrapper around ",(0,i.kt)("inlineCode",{parentName:"p"},"prettyDOM")," which is also exposed and comes from\n",(0,i.kt)("a",{parentName:"p",href:"/docs/dom-testing-library/api-debugging#prettydom"},(0,i.kt)("inlineCode",{parentName:"a"},"DOM Testing Library")),"."),(0,i.kt)("h3",{id:"rerender"},(0,i.kt)("inlineCode",{parentName:"h3"},"rerender")),(0,i.kt)("p",null,"A Marko components ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," can change at any time from a parent component.\nAlthough often this input is passed through your component declaratively,\nsometimes it is necessary to ensure that your components react appropriately to\nnew data. You can simulate your component receiving new ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," by passing new\ndata to the ",(0,i.kt)("inlineCode",{parentName:"p"},"rerender")," helper."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import {render} from '@marko/testing-library'\nimport Greeting from './greeting.marko'\n\nconst {rerender, debug} = await render(Greeting, {name: 'World'})\n\n// re-render the same component with different props\nawait rerender({name: 'Marko'})\n\ndebug()\n// <h1>Hello Marko</h1>\n")),(0,i.kt)("h3",{id:"emitted"},(0,i.kt)("inlineCode",{parentName:"h3"},"emitted")),(0,i.kt)("p",null,"Marko components also communicate with their parents through events. It is\nrecommended to also test that your components emit the right events at the right\ntime."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"emitted")," helper does just that. Calling the helper will return all emitted\nevents since the last call to the helper. You can also pass in an event type to\nfilter the results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'import {render, fireEvent} from \'@marko/testing-library\'\nimport Counter from \'./counter.marko\'\n\nconst {getByText, emitted} = await render(Counter)\n\nconst button = getByText(\'Increment\')\n\nawait fireEvent.click(button)\nawait fireEvent.click(button)\n\n// Assuming the `Counter` component forwards these button clicks as `increment` events\nexpect(emitted(\'increment\')).toHaveProperty(\'length\', 2)\n\nawait fireEvent.click(button)\n\n// Note: the tracked events are cleared every time you read them.\n// Below we are snapshoting the events after our last assertion,\n// the return value will include an array with all of the arguments for each increment event.\nexpect(emitted(\'increment\')).toMatchInlineSnapshot(`\n    Array [\n      Array [\n        Object {\n          "count": 3,\n        },\n      ],\n    ]\n`)\n\n// Without an event type will give you all events with their type and arguments.\nexpect(emitted()).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        "args": Array [\n          Object {\n            "count": 0,\n          },\n        ],\n        "type": "increment",\n      },\n      Object {\n        "args": Array [\n          Object {\n            "count": 1,\n          },\n        ],\n        "type": "increment",\n      },\n      Object {\n        "args": Array [\n          Object {\n            "count": 3,\n          },\n        ],\n        "type": "increment",\n      }\n    ]\n  `)\n')),(0,i.kt)("h3",{id:"cleanup"},(0,i.kt)("inlineCode",{parentName:"h3"},"cleanup")),(0,i.kt)("p",null,"Like the ",(0,i.kt)("a",{parentName:"p",href:"#cleanup-1"},"top-level cleanup method"),", this allows you to remove and\ndestroy the currently rendered component before the test has been completed."),(0,i.kt)("p",null,"This can be useful to validate that a component properly cleans up any DOM\nmutations once it has been destroyed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import {render, screen, getRoles} from '@marko/testing-library'\nimport Main from './main.marko'\nimport Dialog from './dialog.marko'\n\nawait render(Main)\n\nconst main = screen.getByRole('main')\nexpect(main).not.toHaveAttribute('aria-hidden')\n\nconst {cleanup} = await render(Dialog)\nexpect(main).toHaveAttribute('aria-hidden') // assert added attribute\n\ncleanup() // destroy the dialog\n\nexpect(main).not.toHaveAttribute('aria-hidden') // assert attribute removed\n")),(0,i.kt)("h3",{id:"container-1"},(0,i.kt)("inlineCode",{parentName:"h3"},"container")),(0,i.kt)("p",null,"The containing DOM node of your rendered Marko Component. For server-side tests\nthis is a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jsdom/jsdom#fragment"},"JSDOM.fragment"),", and for\nclient-side tests this will be whatever is passed as the ",(0,i.kt)("inlineCode",{parentName:"p"},"container")," render\noption."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tip: To get the root element of your rendered element, use\n",(0,i.kt)("inlineCode",{parentName:"p"},"container.firstChild"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\ud83d\udea8 If you find yourself using ",(0,i.kt)("inlineCode",{parentName:"p"},"container")," to query for rendered elements then\nyou should reconsider! The other queries are designed to be more resilient to\nchanges that will be made to the component you're testing. Avoid using\n",(0,i.kt)("inlineCode",{parentName:"p"},"container")," to query for elements!")),(0,i.kt)("h2",{id:"fireevent"},(0,i.kt)("inlineCode",{parentName:"h2"},"fireEvent")),(0,i.kt)("p",null,"Because Marko batches DOM updates to avoid unnecessary re-renders, the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/dom-testing-library/api-events"},"fireEvent")," helpers are re-exported as\n",(0,i.kt)("inlineCode",{parentName:"p"},"async")," functions. Awaiting this ensures that the DOM has properly updated in\nresponse to the event triggered in the test."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"await fireEvent.click(getByText('Click me'))\n")),(0,i.kt)("h2",{id:"cleanup-1"},(0,i.kt)("inlineCode",{parentName:"h2"},"cleanup")),(0,i.kt)("p",null,"With client-side tests your components are rendered into a placeholder\nHTMLElement. To ensure that your components are properly removed, and destroyed,\nafter each test the ",(0,i.kt)("inlineCode",{parentName:"p"},"cleanup")," method is called for you automatically by hooking\ninto ",(0,i.kt)("inlineCode",{parentName:"p"},"afterEach")," in supported test frameworks. You can also manually call\n",(0,i.kt)("inlineCode",{parentName:"p"},"cleanup")," at any time which will remove all attached components."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import {render, cleanup, screen} from '@marko/testing-library'\nimport Greeting from './greeting.marko'\n\nawait render(Greeting, {name: 'Marko'})\n\nexpect(screen.getByText(/Marko/)).toBeInTheDocument()\n\n// manually cleanup the component before the test is finished\ncleanup()\nexpect(screen.queryByText(/Marko/)).toBeNull()\n")),(0,i.kt)("p",null,"You can turn off the automatic test cleanup by importing the following module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import '@marko/testing-library/dont-cleanup-after-each'\n")),(0,i.kt)("p",null,"With mocha you can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"mocha --require @marko/testing-library/dont-cleanup-after-each")," as a shorthand."),(0,i.kt)("p",null,"If you are using Jest, you can include\n",(0,i.kt)("inlineCode",{parentName:"p"},'setupFilesAfterEnv: ["@marko/testing-library/dont-cleanup-after-each"]')," in your\nJest config to avoid doing this in each file."))}u.isMDXComponent=!0}}]);