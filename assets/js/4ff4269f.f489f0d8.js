"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[5191],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,h=d["".concat(p,".").concat(m)]||d[m]||u[m]||a;return n?o.createElement(h,i(i({ref:t},c),{},{components:n})):o.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3401:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),i=["components"],s={id:"pointer",title:"Pointer"},p=void 0,l={unversionedId:"user-event/pointer",id:"user-event/pointer",title:"Pointer",description:"The pointer API allows to simulate interactions with pointer devices. It",source:"@site/docs/user-event/api-pointer.mdx",sourceDirName:"user-event",slug:"/user-event/pointer",permalink:"/docs/user-event/pointer",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/user-event/api-pointer.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750827853,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"pointer",title:"Pointer"},sidebar:"docs",previous:{title:"Options",permalink:"/docs/user-event/options"},next:{title:"Keyboard",permalink:"/docs/user-event/keyboard"}},c={},u=[{value:"Pointer action",id:"pointer-action",level:2},{value:'<a name="press" href="#"/>Pressing a button or touching the screen',id:"pressing-a-button-or-touching-the-screen",level:3},{value:'<a name="move" href="#"/>Moving a pointer',id:"moving-a-pointer",level:3},{value:"Pointer position",id:"pointer-position",level:2},{value:"PointerTarget",id:"pointertarget",level:3},{value:"SelectionTarget",id:"selectiontarget",level:3}],d={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"pointer(input: PointerInput): Promise<void>\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"pointer")," API allows to simulate interactions with pointer devices. It\naccepts a single pointer action or an array of them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type PointerInput = PointerActionInput | Array<PointerActionInput>\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Our primary target audience tests per ",(0,a.kt)("inlineCode",{parentName:"p"},"jest")," in a ",(0,a.kt)("inlineCode",{parentName:"p"},"jsdom")," environment and\nthere is no layout in ",(0,a.kt)("inlineCode",{parentName:"p"},"jsdom"),". This means that different from your browser the\nelements don't exist in a specific position, layer and size.",(0,a.kt)("br",{parentName:"p"}),"\n","We don't try to determine if the pointer action you describe is possible at\nthat position in your layout.")),(0,a.kt)("h2",{id:"pointer-action"},"Pointer action"),(0,a.kt)("p",null,"There are two types of actions: press and move."),(0,a.kt)("h3",{id:"pressing-a-button-or-touching-the-screen"},(0,a.kt)("a",{name:"press",href:"#"}),"Pressing a button or touching the screen"),(0,a.kt)("p",null,"A pointer action is a press action if it defines a key to be pressed, to be\nreleased, or both."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"pointer({keys: '[MouseLeft]'})\n")),(0,a.kt)("p",null,"You can declare multiple press actions (on the same position) at once which will\nbe resolved to multiple actions internally. If you don't need to declare any\nother properties you can also just supply the ",(0,a.kt)("inlineCode",{parentName:"p"},"keys")," string."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"pointer({keys: '[MouseLeft][MouseRight]'})\n// or\npointer('[MouseLeft][MouseRight]')\n")),(0,a.kt)("p",null,"In order to press a button without releasing it, the button name is suffixed\nwith ",(0,a.kt)("inlineCode",{parentName:"p"},">"),".",(0,a.kt)("br",{parentName:"p"}),"\n","For just releasing a previously pressed button, the tag is started with ",(0,a.kt)("inlineCode",{parentName:"p"},"/"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"pointer('[MouseLeft>]') // press the left mouse button\npointer('[/MouseLeft]') // release the left mouse button\n")),(0,a.kt)("p",null,"Which buttons are available depends on the\n",(0,a.kt)("a",{parentName:"p",href:"/docs/user-event/options#pointermap"},(0,a.kt)("inlineCode",{parentName:"a"},"pointerMap")),"."),(0,a.kt)("h3",{id:"moving-a-pointer"},(0,a.kt)("a",{name:"move",href:"#"}),"Moving a pointer"),(0,a.kt)("p",null,"Every pointer action that is not a press action describes a pointer movement."),(0,a.kt)("p",null,"You can declare which pointer is moved per ",(0,a.kt)("inlineCode",{parentName:"p"},"pointerName")," property. This defaults\nto ",(0,a.kt)("inlineCode",{parentName:"p"},"mouse"),"."),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("inlineCode",{parentName:"p"},"mouse")," pointer (",(0,a.kt)("inlineCode",{parentName:"p"},"pointerId: 1"),") is also the only pointer that\nalways exists and has a position. A ",(0,a.kt)("inlineCode",{parentName:"p"},"touch")," pointer only exists while the screen\nis touched and receives a new ",(0,a.kt)("inlineCode",{parentName:"p"},"pointerId"),' every time. For these pointers, we use\nthe "button" name from the press action as ',(0,a.kt)("inlineCode",{parentName:"p"},"pointerName"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"pointer([\n  // touch the screen at element1\n  {keys: '[TouchA>]', target: element1},\n  // move the touch pointer to element2\n  {pointerName: 'TouchA', target: element2},\n  // release the touch pointer at the last position (element2)\n  {keys: '[/TouchA]'},\n])\n")),(0,a.kt)("h2",{id:"pointer-position"},"Pointer position"),(0,a.kt)("h3",{id:"pointertarget"},"PointerTarget"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface PointerTarget {\n  target: Element\n  coords?: PointerCoords\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"PointerTarget")," props allows to describe the position of the pointer on the\ndocument.",(0,a.kt)("br",{parentName:"p"}),"\n","The ",(0,a.kt)("inlineCode",{parentName:"p"},"coords")," you provide are applied as-is to the resulting\n",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent"},(0,a.kt)("inlineCode",{parentName:"a"},"MouseEvent"))," and\ncan be omitted.",(0,a.kt)("br",{parentName:"p"}),"\n","The ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," should be the element receiving the pointer input in the browser.\nThis is the topmost element that can receive pointer event at those coordinates."),(0,a.kt)("h3",{id:"selectiontarget"},"SelectionTarget"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface SelectionTarget {\n  node?: Node\n  offset?: number\n}\n")),(0,a.kt)("p",null,"Pointer actions can alter the selection in the document.",(0,a.kt)("br",{parentName:"p"}),"\n","In the browser every pointer position corresponds with a DOM position. This is a\nDOM node and a DOM offset which usually translates to the character closest to\nthe pointer position.",(0,a.kt)("br",{parentName:"p"}),"\n","As all character in a no-layout environment are in the same layout position we\nassume a pointer position to be closest to the last descendant of the pointer\n",(0,a.kt)("inlineCode",{parentName:"p"},"target"),"."),(0,a.kt)("p",null,"If you provide ",(0,a.kt)("inlineCode",{parentName:"p"},"offset"),", we assume the pointer position to be closest to the\n",(0,a.kt)("inlineCode",{parentName:"p"},"offset-th")," character of ",(0,a.kt)("inlineCode",{parentName:"p"},"target.textContent"),"."),(0,a.kt)("p",null,"If you also provide ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),", we treat ",(0,a.kt)("inlineCode",{parentName:"p"},"node")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"offset")," as the exact DOM\nposition to be used for any selection."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// element: <div><span>foo</span><span>bar</span></div>\n// | marking the cursor.\n// [ ] marking a selection.\n\npointer({target: element, offset: 2, keys: '[MouseLeft]'})\n// => <div><span>fo|o</span><span>bar</span></div>\n\npointer([{target: element, offset: 2, keys: '[MouseLeft>]'}, {offset: 5}])\n// => <div><span>fo[o</span><span>ba]r</span></div>\n\npointer({target: element, node: element, offset: 1, keys: '[MouseLeft]'})\n// => <div><span>foo</span>|<span>bar</span></div>\n")))}m.isMDXComponent=!0}}]);