"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[6590],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,g=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(g,l(l({ref:t},c),{},{components:n})):a.createElement(g,l({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6852:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>u});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),l=["components"],i={id:"example-react-intl",title:"React Intl"},s=void 0,p={unversionedId:"example-react-intl",id:"example-react-intl",title:"React Intl",description:"Note",source:"@site/docs/example-react-intl.mdx",sourceDirName:".",slug:"/example-react-intl",permalink:"/docs/example-react-intl",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/example-react-intl.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750828179,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"example-react-intl",title:"React Intl"},sidebar:"recipes",previous:{title:"Formik",permalink:"/docs/example-react-formik"},next:{title:"React Redux",permalink:"/docs/example-react-redux"}},c={},u=[{value:"Configuring React-Intl Polyfills / Locales",id:"configuring-react-intl-polyfills--locales",level:2},{value:"Creating a custom render function",id:"creating-a-custom-render-function",level:2},{value:"A complete example",id:"a-complete-example",level:2},{value:"Translated components testing stategy",id:"translated-components-testing-stategy",level:2}],d={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note")),(0,o.kt)("p",{parentName:"blockquote"},"If you want to combine setupTests with another setup you should check\n",(0,o.kt)("a",{parentName:"p",href:"/docs/react-testing-library/setup"},(0,o.kt)("inlineCode",{parentName:"a"},"setup")))),(0,o.kt)("h2",{id:"configuring-react-intl-polyfills--locales"},"Configuring React-Intl Polyfills / Locales"),(0,o.kt)("p",null,"If you're using React-Intl in your project, and you ",(0,o.kt)("strong",{parentName:"p"},"need")," to load a locale,\nYou have two options:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"When using Node 13 and higher, Intl support is now out of the box. The\ndefault ICU (International Components for Unicode) option for Node is\n",(0,o.kt)("inlineCode",{parentName:"p"},"full-icu")," meaning all ICU's.",(0,o.kt)("br",{parentName:"p"}),"\n","All you need to do is embed the set of ICU data you need:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// test-utils.js\n\nconst hasFullICU = () => {\n  // That's the recommended way to test for ICU support according to Node.js docs\n  try {\n    const january = new Date(9e8)\n    const pt = new Intl.DateTimeFormat('pt', {month: 'long'})\n    return pt.format(january) === 'janeiro'\n  } catch (err) {\n    return false\n  }\n}\n\nexport const setupTests = () => {\n  if (hasFullICU()) {\n    Intl.NumberFormat.format = new Intl.NumberFormat('pt').format\n    Intl.DateTimeFormat.format = new Intl.DateTimeFormat('pt').format\n  } else {\n    global.Intl = IntlPolyfill\n  }\n}\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"When using Node with prior versions, the ICU default option is ",(0,o.kt)("inlineCode",{parentName:"p"},"small-icu"),"\nmeaning it includes a subset of ICU data (typically only the English\nlocale).",(0,o.kt)("br",{parentName:"p"}),"\n","If you do need to load a locale you have two options:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Load the Polyfills according to that language:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// test-utils.js\nimport IntlPolyfill from 'intl'\nimport 'intl/locale-data/jsonp/pt'\n\nexport const setupTests = () => {\n  // https://formatjs.io/docs/guides/runtime-requirements/#nodejs\n  if (global.Intl) {\n    Intl.NumberFormat = IntlPolyfill.NumberFormat\n    Intl.DateTimeFormat = IntlPolyfill.DateTimeFormat\n  } else {\n    global.Intl = IntlPolyfill\n  }\n}\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Load the ICU's at runtime:",(0,o.kt)("br",{parentName:"p"}),"\n","Install the package\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/unicode-org/full-icu-npm"},"full-icu")," and inject it to\nyour test environment, you can do that by setting ",(0,o.kt)("inlineCode",{parentName:"p"},"NODE_ICU_DATA")," before\ncalling jest: ",(0,o.kt)("inlineCode",{parentName:"p"},"NODE_ICU_DATA=node_modules/full-icu jest"),". Doing that you\nwill give you full-icu support as shown in option 1."))))),(0,o.kt)("h2",{id:"creating-a-custom-render-function"},"Creating a custom render function"),(0,o.kt)("p",null,"To test our translated component we can create a custom ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," function using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapper")," option as explained in the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/react-testing-library/setup"},"setup")," page.",(0,o.kt)("br",{parentName:"p"}),"\n","Our custom ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," function can look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"// test-utils.js\nimport React from 'react'\nimport {render as rtlRender} from '@testing-library/react'\nimport {IntlProvider} from 'react-intl'\n\nfunction render(ui, {locale = 'pt', ...renderOptions} = {}) {\n  function Wrapper({children}) {\n    return <IntlProvider locale={locale}>{children}</IntlProvider>\n  }\n  return rtlRender(ui, {wrapper: Wrapper, ...renderOptions})\n}\n\n// re-export everything\nexport * from '@testing-library/react'\n\n// override render method\nexport {render}\n")),(0,o.kt)("h2",{id:"a-complete-example"},"A complete example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'\nimport '@testing-library/jest-dom'\n// We're importing from our own created test-utils and not RTL's\nimport {render, screen, setupTests} from '../test-utils.js'\nimport {FormattedDate} from 'react-intl'\n\nconst FormatDateView = () => {\n  return (\n    <div data-testid=\"date-display\">\n      <FormattedDate\n        value=\"2019-03-11\"\n        timeZone=\"utc\"\n        day=\"2-digit\"\n        month=\"2-digit\"\n        year=\"numeric\"\n      />\n    </div>\n  )\n}\n\nsetupTests()\n\ntest('it should render FormattedDate and have a formatted pt date', () => {\n  render(<FormatDateView />)\n  expect(screen.getByTestId('date-display')).toHaveTextContent('11/03/2019')\n})\n")),(0,o.kt)("h2",{id:"translated-components-testing-stategy"},"Translated components testing stategy"),(0,o.kt)("p",null,"When testing a translated component there can be different approaches for\nachieving the wanted coverage, where the aimed goal should be to allow testing\nthe component in a way that will simulate the user behavior as much as posible."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Approach"),(0,o.kt)("th",{parentName:"tr",align:"left"},"Pros"),(0,o.kt)("th",{parentName:"tr",align:"left"},"Cons"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Use strings from the default language"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Test is easy to read, and asserts expected default output. If you have variables in your strings, you can test that they work properly with correct output."),(0,o.kt)("td",{parentName:"tr",align:"left"},"1. Strings hardcoded into tests mean you have to update both tests and code for any copy changes. 2. If multiple elements have the same string/substring text, find-and-replace may be hard to use reliably.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Mock the translation library"),(0,o.kt)("td",{parentName:"tr",align:"left"},"If your library is difficult to use in the test environment, you can mock it so it is easier. For example, you can add the message ID as a data-attribute to the text so you can query by that."),(0,o.kt)("td",{parentName:"tr",align:"left"},"Test code deviates from what runs in production. Tests may assert about message IDs but not enough about content, so errors are possible.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Use translation library in tests"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Decouples strings from tests, so you can update the message files in one place without worrying about breaking tests. Can run tests in another language or multiple languages. ",(0,o.kt)("inlineCode",{parentName:"td"},'const buttonText = getNodeText(<FormattedMessage id="buttonText" defaultMessage="Hello Button" />);')),(0,o.kt)("td",{parentName:"tr",align:"left"},"Overhead - it takes more lines of code to write the test, and you need to know the variables and message IDs to create the right strings. It's not obvious what the text actually is when you read the test code, making maintaining it harder.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Use translation library + inline snapshots"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Same as above, but by adding an inline snapshot of the string, you can read the test code and see what strings are in use, but easily update them with ",(0,o.kt)("inlineCode",{parentName:"td"},"jest --updateSnapshot")," if the messages change. ",(0,o.kt)("inlineCode",{parentName:"td"},"expect(buttonText).toMatchInlineSnapshot(\"'My button text'\")")),(0,o.kt)("td",{parentName:"tr",align:"left"},"Tests are longer because of the extra lines. You can wrap up some of the translation-related code into a helper function to make it a little more inline-able and avoid repeating yourself, but you still need to know the message IDs and variables inside the test.")))))}m.isMDXComponent=!0}}]);