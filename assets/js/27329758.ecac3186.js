"use strict";(self.webpackChunkreact_testing_library_docs=self.webpackChunkreact_testing_library_docs||[]).push([[2357],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"api",title:"API",sidebar_label:"API"},l=void 0,p={unversionedId:"solid-testing-library/api",id:"solid-testing-library/api",title:"API",description:"Due to being inspired by the preact-testing-library you can check",source:"@site/docs/solid-testing-library/api.mdx",sourceDirName:"solid-testing-library",slug:"/solid-testing-library/api",permalink:"/docs/solid-testing-library/api",draft:!1,editUrl:"https://github.com/testing-library/testing-library-docs/edit/main/docs/solid-testing-library/api.mdx",tags:[],version:"current",lastUpdatedBy:"Jiaqi Liu",lastUpdatedAt:1750828179,formattedLastUpdatedAt:"Jun 25, 2025",frontMatter:{id:"api",title:"API",sidebar_label:"API"},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/solid-testing-library/intro"},next:{title:"Introduction",permalink:"/docs/qwik-testing-library/intro"}},d={},c=[{value:"<code>render</code>",id:"render",level:2},{value:"<code>renderHook</code>",id:"renderhook",level:2},{value:"<code>renderDirective</code>",id:"renderdirective",level:2},{value:"Async methods",id:"async-methods",level:2},{value:"Known issues",id:"known-issues",level:2}],u={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Due to being inspired by the ",(0,i.kt)("a",{parentName:"p",href:"/docs/preact-testing-library/intro"},"preact-testing-library")," you can check\nits page for more information."),(0,i.kt)("p",null,"There are several key differences, to be aware of."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#render"},(0,i.kt)("inlineCode",{parentName:"a"},"render"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#renderHook"},(0,i.kt)("inlineCode",{parentName:"a"},"renderHook"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#renderDirective"},(0,i.kt)("inlineCode",{parentName:"a"},"renderDirective"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#async-methods"},(0,i.kt)("inlineCode",{parentName:"a"},"Async methods"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#known-issues"},(0,i.kt)("inlineCode",{parentName:"a"},"Known issues")))),(0,i.kt)("h2",{id:"render"},(0,i.kt)("inlineCode",{parentName:"h2"},"render")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," function takes in a function that returns a Solid Component, rather\nthan simply the component itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const results = render(() => <YourComponent />, options)\n")),(0,i.kt)("p",null,"Solid.js does ",(0,i.kt)("em",{parentName:"p"},"not")," re-render, it merely executes side effects triggered by\nreactive state that change the DOM, therefore there is no ",(0,i.kt)("inlineCode",{parentName:"p"},"rerender")," method. You\ncan use global signals to manipulate your test component in a way that causes it\nto update."),(0,i.kt)("p",null,"In addition to the original API, the render function of this testing library\nsupports a convenient ",(0,i.kt)("inlineCode",{parentName:"p"},"location")," option that will set up an in-memory router\npointing at the specified location. Since this setup is not synchronous, you\nneed to first use asynchronous queries (",(0,i.kt)("inlineCode",{parentName:"p"},"findBy"),") after employing it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"it('uses params', async () => {\n  const App = () => (\n    <>\n      <Route path=\"/ids/:id\" component={() => <p>Id: {useParams()?.id}</p>} />\n      <Route path=\"/\" component={() => <p>Start</p>} />\n    </>\n  )\n  const {findByText} = render(() => <App />, {location: 'ids/1234'})\n  expect(await findByText('Id: 1234')).not.toBeFalsy()\n})\n")),(0,i.kt)("p",null,"It uses ",(0,i.kt)("inlineCode",{parentName:"p"},"@solidjs/router"),", so if you want to use a different router, you should\nconsider the ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapper")," option instead. If you attempt to use this without having\nthe package installed, you will receive an error message."),(0,i.kt)("h2",{id:"renderhook"},(0,i.kt)("inlineCode",{parentName:"h2"},"renderHook")),(0,i.kt)("p",null,"Solid.js external reactive state does not require any DOM elements to run in, so\nour ",(0,i.kt)("inlineCode",{parentName:"p"},"renderHook")," call to test hooks in the context of a component (if your hook\ndoes not require the context of a component, ",(0,i.kt)("inlineCode",{parentName:"p"},"createRoot")," should suffice to test\nthe reactive behavior; for convenience, we also have ",(0,i.kt)("inlineCode",{parentName:"p"},"createEffect"),", which is\ndescribed in the ",(0,i.kt)("a",{parentName:"p",href:"#async-methods"},(0,i.kt)("inlineCode",{parentName:"a"},"Async methods"))," section) has no ",(0,i.kt)("inlineCode",{parentName:"p"},"container"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"baseElement")," or queries in its options or return value. Instead, it has an\n",(0,i.kt)("inlineCode",{parentName:"p"},"owner")," to be used with\n",(0,i.kt)("a",{parentName:"p",href:"https://www.solidjs.com/docs/latest/api#runwithowner"},(0,i.kt)("inlineCode",{parentName:"a"},"runWithOwner"))," if\nrequired. It also exposes a ",(0,i.kt)("inlineCode",{parentName:"p"},"cleanup")," function, though this is already\nautomatically called after the test is finished."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function renderHook<Args extends any[], Result>(\n  hook: (...args: Args) => Result,\n  options: {\n    initialProps?: Args,\n    wrapper?: Component<{ children: JSX.Element }>\n  }\n) => {\n  result: Result;\n  owner: Owner | null;\n  cleanup: () => void;\n}\n")),(0,i.kt)("p",null,"This can be used to easily test a hook / primitive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const {result} = renderHook(createResult)\nexpect(result).toBe(true)\n")),(0,i.kt)("p",null,"If you are using a ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapper")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"renderHook"),", make sure it will ",(0,i.kt)("strong",{parentName:"p"},"always"),"\nreturn ",(0,i.kt)("inlineCode",{parentName:"p"},"props.children")," - especially if you are using a context with\nasynchronous code together with ",(0,i.kt)("inlineCode",{parentName:"p"},"<Show>"),", because this is required to get the\nvalue from the hook and it is only obtained synchronously once and you will\notherwise only get ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," and wonder why this is the case."),(0,i.kt)("h2",{id:"renderdirective"},(0,i.kt)("inlineCode",{parentName:"h2"},"renderDirective")),(0,i.kt)("p",null,"Solid.js supports\n",(0,i.kt)("a",{parentName:"p",href:"https://www.solidjs.com/docs/latest/api#use___"},"custom directives"),", which is a\nconvenient pattern to tie custom behavior to elements, so we also have a\n",(0,i.kt)("inlineCode",{parentName:"p"},"renderDirective")," call, which augments ",(0,i.kt)("inlineCode",{parentName:"p"},"renderHook")," to take a directive as first\nargument, accept an ",(0,i.kt)("inlineCode",{parentName:"p"},"initialValue")," for the argument and a ",(0,i.kt)("inlineCode",{parentName:"p"},"targetElement"),"\n(string, HTMLElement or function returning an HTMLElement) in the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," and\nalso returns ",(0,i.kt)("inlineCode",{parentName:"p"},"arg")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"setArg")," to read and manipulate the argument of the\ndirective."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function renderDirective<\n  Arg extends any,\n  Elem extends HTMLElement\n>(\n  directive: (ref: Elem, arg: Accessor<Arg>) => void,\n  options?: {\n    ...renderOptions,\n    initialValue: Arg,\n    targetElement:\n      | Lowercase<Elem['nodeName']>\n      | Elem\n      | (() => Elem)\n  }\n): Result & { arg: Accessor<Arg>, setArg: Setter<Arg> };\n")),(0,i.kt)("p",null,"This allows for very effective and concise testing of directives:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const {asFragment, setArg} = renderDirective(myDirective)\nexpect(asFragment()).toBe('<div data-directive=\"works\"></div>')\nsetArg('perfect')\nexpect(asFragment()).toBe('<div data-directive=\"perfect\"></div>')\n")),(0,i.kt)("h2",{id:"async-methods"},"Async methods"),(0,i.kt)("p",null,"Solid.js reactive changes are pretty instantaneous, so there is rarely need to\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"waitFor(\u2026)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"await findByRole(\u2026)")," and other asynchronous queries to test\nthe rendered result, except for transitions, suspense, resources and router\nnavigation."),(0,i.kt)("p",null,"Solid.js manages side effects with different variants of ",(0,i.kt)("inlineCode",{parentName:"p"},"createEffect"),". While\nyou can use ",(0,i.kt)("inlineCode",{parentName:"p"},"waitFor")," to test asynchronous effects, it uses polling instead of\nallowing Solid's reactivity to trigger the next step. In order to simplify\ntesting those asynchronous effects, we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"testEffect")," helper that\ncomplements the hooks for directives and hooks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'testEffect(fn: (done: (result: T) => void) => void, owner?: Owner): Promise<T>\n\n// use it like this:\ntest("testEffect allows testing an effect asynchronously", () => {\n  const [value, setValue] = createSignal(0);\n  return testEffect(done => createEffect((run: number = 0) => {\n    if (run === 0) {\n      expect(value()).toBe(0);\n      setValue(1);\n    } else if (run === 1) {\n      expect(value()).toBe(1);\n      done();\n    }\n    return run + 1;\n  }));\n});\n')),(0,i.kt)("p",null,"It allows running the effect inside a defined owner that is received as an\noptional second argument. This can be useful in combination with ",(0,i.kt)("inlineCode",{parentName:"p"},"renderHook"),",\nwhich gives you an owner field in its result. The return value is a Promise with\nthe value given to the ",(0,i.kt)("inlineCode",{parentName:"p"},"done()")," callback. You can either await the result for\nfurther assertions or return it to your test runner."),(0,i.kt)("h2",{id:"known-issues"},"Known issues"),(0,i.kt)("p",null,"If you are using ",(0,i.kt)("a",{parentName:"p",href:"https://vitest.dev/"},(0,i.kt)("inlineCode",{parentName:"a"},"vitest")),", then tests might fail, because\nthe packages ",(0,i.kt)("inlineCode",{parentName:"p"},"solid-js"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"@solidjs/router")," (if used) need to be loaded only\nonce, and they could be loaded both through the internal ",(0,i.kt)("inlineCode",{parentName:"p"},"vite")," server and\nthrough node. Typical bugs that happen because of this is that dispose is\nsupposedly undefined, or the router could not be loaded."),(0,i.kt)("p",null,"Since version 2.8.2, our vite plugin has gained the capability to configure\neverything for testing, so you should only need extra configuration for globals,\ncoverage, etc."))}m.isMDXComponent=!0}}]);